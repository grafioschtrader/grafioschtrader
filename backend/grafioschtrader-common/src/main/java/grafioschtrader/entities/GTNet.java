package grafioschtrader.entities;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;

import grafiosch.common.PropertyOnlyCreation;
import grafiosch.entities.BaseID;
import grafioschtrader.gtnet.GTNetServerStateTypes;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.persistence.Basic;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

/**
 * Represents a remote domain configuration in the GT-Network (GTNet) peer-to-peer system.
 *
 * Each GTNet entry defines a connection to another Grafioschtrader instance, including authentication tokens,
 * capability flags, rate limits, and server state information. The local instance maintains one entry per
 * known remote domain, plus an entry representing itself (identified via {@code gtnet.my.entry.id} global parameter).
 *
 * The handshake process works as follows:
 * <ol>
 *   <li>Local instance generates {@code tokenThis} and sends it to the remote domain</li>
 *   <li>Remote domain stores the token as its {@code tokenRemote} for that peer</li>
 *   <li>Remote domain replies with its own generated token, which becomes local {@code tokenRemote}</li>
 *   <li>All subsequent M2M calls include the remote-supplied token in the Authorization header</li>
 * </ol>
 *
 * @see GTNetMessage for inter-instance messaging
 * @see GTNetExchange for entity exchange tracking
 * @see GTNetServerStateTypes for server availability states
 */
@Entity
@Table(name = GTNet.TABNAME)
@Schema(description = """
    Represents a remote domain configuration in the GT-Network peer-to-peer system. Each entry defines a connection
    to another Grafioschtrader instance, including authentication tokens, capability flags for entity and intraday
    price sharing, rate limiting configuration, and server state information. The local instance maintains one entry
    per known remote domain, plus an entry representing itself.""")
public class GTNet extends BaseID<Integer> {

  public static final String TABNAME = "gt_net";

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Column(name = "id_gt_net")
  private Integer idGtNet;

  @Schema(description = """
      Base URL of the remote domain (e.g., 'https://example.com:8080'). Used as the target for all M2M HTTP requests.
      When this URL resolves to the local machine's network interfaces, the entry is identified as 'my entry' and its
      ID is stored in the global parameter 'gtnet.my.entry.id'.""")
  @NotNull
  // @WebUrl
  @Column(name = "domain_remote_name")
  private String domainRemoteName;

  @Schema(description = """
      Java timezone identifier (e.g., 'Europe/Zurich', 'America/New_York'). Helps users understand the operating
      hours of the remote server and is used for maintenance window announcements.""")
  @Basic(optional = false)
  @NotNull
  @Size(min = 1, max = 50)
  @Column(name = "time_zone")
  @PropertyOnlyCreation
  private String timeZone;

  @JsonIgnore
  @Schema(description = """
      Authentication token generated by this server during the first handshake. This token is sent to the remote
      domain and stored there as tokenRemote. The remote domain must include this token in the Authorization header
      when making requests to this server. Marked @JsonIgnore to prevent accidental exposure via REST API.""")
  @Column(name = "token_this")
  private String tokenThis;

  @JsonIgnore
  @Schema(description = """
      Authentication token received from the remote domain during the first handshake. This token must be included
      in the Authorization header when this server makes requests to the remote domain. Marked @JsonIgnore to
      prevent accidental exposure via REST API. Set to null if the handshake has not been completed.""")
  @Column(name = "token_remote")
  private String tokenRemote;

  @Schema(description = """
      Controls whether this domain's server list may be redistributed to other domains. When true, a third party
      can request and receive information about this server's known peers, enabling network discovery beyond
      direct connections.""")
  @Column(name = "spread_capability")
  private boolean spreadCapability;

  @Schema(description = """
      Server state for entity/historical data sharing. Indicates whether this server is available to provide entity
      data (e.g., historical quotes) to the remote domain. Uses GTNetServerStateTypes enum values: SS_NONE (0),
      SS_FAILED_HANDSHAKE (1), SS_CLOSED (2), SS_MAINTENANCE (3), SS_OPEN (4).""")
  @JsonIgnore
  @Column(name = "entity_server_state")
  private byte entityServerState;

  @Schema(description = """
      Enables bidirectional entity data exchange. When true, this server accepts entity data requests from the
      remote domain, allowing mutual data sharing. When false, entity exchange is unidirectional or disabled.""")
  @Column(name = "accept_entity_request")
  private boolean acceptEntityRequest;

  @Schema(description = """
      Maximum number of data requests the remote domain can make to this server per day. This limit protects the
      local server from excessive load. Set to null for unlimited requests. The counter (dailyRequestLimitCount)
      tracks usage and resets at UTC midnight.""")
  @Column(name = "daily_req_limit")
  private Integer dailyRequestLimit;

  @Schema(description = """
      Current count of requests received from the remote domain today. Incremented with each incoming request and
      compared against dailyRequestLimit to enforce rate limiting. Automatically reset to null at UTC 00:00 by a
      scheduled background job.""")
  @Column(name = "daily_req_limit_count")
  private Integer dailyRequestLimitCount;

  @Schema(description = """
      Maximum number of data requests this server can make to the remote domain per day. This value is typically
      communicated by the remote domain during handshake or negotiation. Set to null if no limit was specified.""")
  @Column(name = "daily_req_limit_remote")
  private Integer dailyRequestLimitRemote;

  @Schema(description = """
      Current count of requests this server has made to the remote domain today. Used to self-limit outgoing
      requests before hitting the remote's rate limit. Automatically reset to null at UTC 00:00 by a scheduled
      background job.""")
  @Column(name = "daily_req_limit_remote_count")
  private Integer dailyRequestLimitRemoteCount;

  @Schema(description = """
      Server state for intraday price sharing. Indicates whether the remote domain is available to provide
      intraday/last price data. Uses GTNetServerStateTypes enum values: SS_NONE (0), SS_FAILED_HANDSHAKE (1),
      SS_CLOSED (2), SS_MAINTENANCE (3), SS_OPEN (4).""")
  @JsonIgnore
  @Column(name = "lastprice_server_state")
  private byte lastpriceServerState;

  @Schema(description = """
      Enables acceptance of intraday price requests from the remote domain. When true, this server will respond
      to last price queries from the remote. Used in conjunction with lastpriceServerState to determine actual
      availability.""")
  @Column(name = "accept_lastprice_request")
  private boolean acceptLastpriceRequest;

  @Schema(description = """
      Priority level for using this remote domain as an intraday price provider. Value 0 means this provider is
      not used. Values greater than 0 indicate priority (lower numbers = higher priority). Multiple providers can
      be configured with different priorities for failover scenarios.""")
  @Column(name = "lastprice_consumer_usage")
  private byte lastpriceConsumerUsage;

  @Schema(description = """
      Enables detailed logging of intraday price updates from this remote domain. When true, each price change is
      recorded in GTNetLastpriceDetailLog, providing an audit trail of which client changed which prices and when.
      May impact performance when enabled for high-volume providers.""")
  @Column(name = "lastprice_use_detail_log")
  private boolean lastpriceUseDetailLog;

  public Integer getIdGtNet() {
    return idGtNet;
  }

  public void setIdGtNet(Integer idGtNet) {
    this.idGtNet = idGtNet;
  }

  public String getDomainRemoteName() {
    return domainRemoteName;
  }

  public void setDomainRemoteName(String domainRemoteName) {
    this.domainRemoteName = domainRemoteName;
  }

  public String getTimeZone() {
    return timeZone;
  }

  public void setTimeZone(String timeZone) {
    this.timeZone = timeZone;
  }

  public String getTokenThis() {
    return tokenThis;
  }

  public void setTokenThis(String tokenThis) {
    this.tokenThis = tokenThis;
  }

  public String getTokenRemote() {
    return tokenRemote;
  }

  public void setTokenRemote(String tokenRemote) {
    this.tokenRemote = tokenRemote;
  }

  public boolean isSpreadCapability() {
    return spreadCapability;
  }

  public void setSpreadCapability(boolean spreadCapability) {
    this.spreadCapability = spreadCapability;
  }

  @JsonProperty("entityServerState")
  public GTNetServerStateTypes getEntityServerState() {
    return GTNetServerStateTypes.getGTNetServerStateType(entityServerState);
  }

  @JsonProperty("entityServerState")
  public void setEntityServerState(GTNetServerStateTypes entityServerState) {
    this.entityServerState = entityServerState.getValue();
  }

  public boolean isAcceptEntityRequest() {
    return acceptEntityRequest;
  }

  public void setAcceptEntityRequest(boolean acceptEntityRequest) {
    this.acceptEntityRequest = acceptEntityRequest;
  }

  public Integer getDailyRequestLimit() {
    return dailyRequestLimit;
  }

  public void setDailyRequestLimit(Integer dailyRequestLimit) {
    this.dailyRequestLimit = dailyRequestLimit;
  }

  public Integer getDailyRequestLimitCount() {
    return dailyRequestLimitCount;
  }

  public void setDailyRequestLimitCount(Integer dailyRequestLimitCount) {
    this.dailyRequestLimitCount = dailyRequestLimitCount;
  }

  public Integer getDailyRequestLimitRemote() {
    return dailyRequestLimitRemote;
  }

  public void setDailyRequestLimitRemote(Integer dailyRequestLimitRemote) {
    this.dailyRequestLimitRemote = dailyRequestLimitRemote;
  }

  public Integer getDailyRequestLimitRemoteCount() {
    return dailyRequestLimitRemoteCount;
  }

  public void setDailyRequestLimitRemoteCount(Integer dailyRequestLimitRemoteCount) {
    this.dailyRequestLimitRemoteCount = dailyRequestLimitRemoteCount;
  }

  @JsonProperty("lastpriceServerState")
  public GTNetServerStateTypes getLastpriceServerState() {
    return GTNetServerStateTypes.getGTNetServerStateType(lastpriceServerState);
  }

  @JsonProperty("lastpriceServerState")
  public void setLastpriceServerState(GTNetServerStateTypes lastpriceServerState) {
    this.lastpriceServerState = lastpriceServerState.getValue();
  }

  public boolean isAcceptLastpriceRequest() {
    return acceptLastpriceRequest;
  }

  public void setAcceptLastpriceRequest(boolean acceptLastpriceRequest) {
    this.acceptLastpriceRequest = acceptLastpriceRequest;
  }

  public byte getLastpriceConsumerUsage() {
    return lastpriceConsumerUsage;
  }

  public void setLastpriceConsumerUsage(byte lastpriceConsumerUsage) {
    this.lastpriceConsumerUsage = lastpriceConsumerUsage;
  }

  public boolean isLastpriceUseDetailLog() {
    return lastpriceUseDetailLog;
  }

  public void setLastpriceUseDetailLog(boolean lastpriceUseDetailLog) {
    this.lastpriceUseDetailLog = lastpriceUseDetailLog;
  }

  @Override
  public Integer getId() {
    return idGtNet;
  }

}
